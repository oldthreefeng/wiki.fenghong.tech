---
title: "Go 位运算详解"
date: 2019-09-17 00:40
tag: 
  - go
  - bit
  - algorithm
---

[TOC]

> ### 背景
>
> 位运算一直都懵懵懂懂,需要记录成文字.时常看看

## 位操作


1. 判断某一位是否为1
2. 只改变其中某一位,而保持其他位不变

- 按位与`&`

```cgo
& 只有两个二进制位均为1,结果才是1;其他都是0.
例如: 获取某些变量中的某一位,某些位清0且同事保留其他位不变;
n = n & 0xffffff00  (低8位置0)

如何判断int型变量n的第7位,(右往左,从0开始).
```

- 按位或`|`

```cgo
| 只有两个二进制有一个1,结果会为1,其他都是0
例如: 通过用来将变量的某些为置1保留其他位不变
n|= 0xff (将n的低8位置1)

```
- 按位异或`^`

```cgo
^ 只有两个二进制位不相同,结果才为1,其他都是0
例如: 将某些变种的某些位进行取反,且保留其他位
特点 如果a^b=c, 那么就有 c^b=a ,c^a=b (穷举法)

```
假定 A 为60，B 为13

| 运算符 | 描述                                                         | 实例                                   |
| :----- | :----------------------------------------------------------- | :------------------------------------- |
| &      | 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 | (A & B) 结果为 12, 二进制为 0000 1100  |
| \|     | 按位或运算符"\|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 | (A \| B) 结果为 61, 二进制为 0011 1101 |
| ^      | 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 | (A ^ B) 结果为 49, 二进制为 0011 0001  |
| <<     | 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | A << 2 结果为 240 ，二进制为 1111 0000 |
| >>     | 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 | A >> 2 结果为 15 ，二进制为 0000 1111  |

## 示例

- 获取c的第i位的bit值.

```go
func GetBit(c byte, i uint) byte {
	return (c >> i) & 0x1
}
```

- 将c的第i位设置为v.

```go
func SetBit(c byte, i uint, v int) byte {
	if v != 0 {
		/**
		将某一位设置为1，例如设置第8位，从右向左数需要偏移7位,注意不要越界
		1<<7=1000 0000 然后与c逻辑或|,偏移后的第8位为1，逻辑|运算时候只要1个为真就为真达到置1目的
		*/
		c |= 1 << i
	} else {
		/**
		将某一位设置为0，例如设置第4位，从右向左数需要偏移3位,注意不要越界
		1<<3=0000 1000 然后取反得到 1111 0111 然后逻辑&c
		*/
		c = &^ (1 << i)
	}
}
```

- 将c的第i位翻转

```go
func FlipBit(c byte, i uint) byte {
	c = c ^ (1 << i)
	/*
	将第4位翻转, 1左移3位, 1 << 3 ==> 0000 1000
	0000 1000 ^ 0001 1110 == 0001 0110
	*/
	return c
}
```

### 判断为2的幂

- 位运算

```go
func IsPowerOfTwo(n int) bool {
	if n <= 0 {
		return false
	}
    /*
    n位2的幂时, 	2^7   == 1000 0000
    n-1为 	   	  2^7-1 == 0111 1111
    n & (n-1)为,	        == 0000 0000 
    */
    return !(n & (n-1))
}
```

- 普通递归

```go
func IsPowerOfTwo(n int) bool {
	if n <= 0 {
		return false
	}
    // 2的幂一直除2, 最后等于1
	if n == 1 {
		return true
	}
    // n为奇数,必定不为2的幂
	if n % 2 != 0 { 
		return false
	} 
	return isPowerOfTwo(n / 2)
}
```

### 验证

```go
package main

import (
	"fmt"
	"github.com/imroc/biu"
)

func main() {
	var a byte
	a = 30 //00011110
	b := GetBit(a, 2)
	fmt.Printf("%d二进制为:%v\n", a, biu.ToBinaryString(a))
	fmt.Printf("a的第2位为:%v\n", b)
	b = SetBit(a, 5, 1)
	fmt.Printf("%d的第6位,置为1后的二进制为:%v\n", a, biu.ToBinaryString(b))
	b = SetBit(a, 6, 1)
	fmt.Printf("%d的第7位,置为1后的二进制为:%v\n", a, biu.ToBinaryString(b))
	b = SetBit(a, 7, 1)
	fmt.Printf("%d的第8位,置为1后的二进制为:%v\n", a, biu.ToBinaryString(b))
	b = SetBit(a, 0, 1)
	fmt.Printf("%d的第1位,置为1后的二进制为:%v\n", a, biu.ToBinaryString(b))
	b = SetBit(a, 1, 0)
	fmt.Printf("%d的第2位,置为0后的二进制为:%v\n", a, biu.ToBinaryString(b))

	for i := 0; i < 20; i++ {
		if IsPowerOfTwo(i) {
			fmt.Printf("%d \tisPowerOfTwo\n", i)
		}
	}
}
```

- output

```
30二进制为:00011110
a的第2位为:1
30的第6位,置为1后的二进制为:00111110
30的第7位,置为1后的二进制为:01011110
30的第8位,置为1后的二进制为:10011110
30的第1位,置为1后的二进制为:00011111
30的第2位,置为0后的二进制为:00011100
1 	isPowerOfTwo
2 	isPowerOfTwo
4 	isPowerOfTwo
8 	isPowerOfTwo
16 	isPowerOfTwo
```

### 参考

- [位运算](https://studygolang.com/articles/14276)


